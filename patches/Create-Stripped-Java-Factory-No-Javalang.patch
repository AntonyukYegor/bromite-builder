diff -drupN a/chrome/android/features/create_stripped_java_factory.py b/chrome/android/features/create_stripped_java_factory.py
--- a/chrome/android/features/create_stripped_java_factory.py	2019-09-16 12:23:55.732657630 -0400
+++ b/chrome/android/features/create_stripped_java_factory.py	2019-09-16 12:31:08.114838757 -0400
@@ -14,161 +14,104 @@ Afterwards, the stripped down factory's
 resulting target. The real factory uses the feature's internal implementations,
 which is why it is not included in the feature's public_java target.
 
-This script generates a stripped down factory file from real factory file to
-reduce the burden of maintenance. The stripped down factory will have dummy
-implementations of all public methods of the real factory.
+This script generates stripped down factory files from real factory files to
+reduce the burden of maintenance. It checks to make sure that these factory
+files are as simple as possible and replaces multi-line java return statements
+with 'return null;'.
 
-This script requires that the real factory file has exactly one top-level class.
+In order to keep the regex simple and easily understood, the java factory files
+have a few strict requirements. This avoids the need to take care of every
+corner case involving comments or strings. Since the generated factory file is
+only used during the build, and the real one is used at runtime, it is
+sufficient to have the build pass with simple modifications.
+
+We require that these factory files to:
+  - Contain exactly one top-level class.
+    - No inner classes.
+  - Contain a private constructor with no arguments (it won't be used).
+  - Contain only public static methods apart from the constructor.
+    - Only void and object return types are supported (no primitives).
+  - Avoid explicitly importing internal classes and their dependencies.
+    - The factory should be in the same package as the internal classes it
+      instantiates.
 """
 
 import argparse
-import datetime
-import sys
+import re
 import os
+import sys
 
 sys.path.append(os.path.join(os.path.dirname(__file__),
                              os.pardir, os.pardir, os.pardir,
                              'build', 'android', 'gyp'))
 from util import build_utils
 
-sys.path.append(
-    os.path.join(
-        os.path.dirname(__file__), os.pardir, os.pardir, os.pardir,
-        'third_party', 'javalang', 'src'))
-import javalang
 
-_PARAM_TEMPLATE = '{TYPE} {NAME}'
-_METHOD_TEMPLATE = ('{MODIFIERS} {RETURN_TYPE} {NAME} ({PARAMS}) '
-                    '{{ return {RETURN_VAL}; }}')
-_FILE_TEMPLATE = '''\
-// Copyright {YEAR} The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-//
-// This file is autogenerated by
-//     {SCRIPT_NAME}
-// Please do not change its content.
-
-package {PACKAGE};
-
-{IMPORTS}
-
-{MODIFIERS} class {CLASS_NAME} {{
-{METHODS}
-}}
-'''
+# Matches multi-line public static methods:
+# '^(    public static ' - Matches the first part of the method signature.
+# '(?!void)' - Do not match methods signatures that return void.
+# '[^{]+ {)' - Matches the rest of the method signature until the opening brace.
+# '.+?' - Non-greedy match to only match one method body.
+# '^(    })$' - Matches the closing brace of the method.
+_RE_PUBLIC_STATIC_NOT_VOID_METHOD = re.compile(
+    r'^(    public static (?!void)[^{]+ {).+?^(    })$',
+    re.DOTALL | re.MULTILINE)
+# Replacement string to replace the entire method body with a null return.
+_RETURN_NULL = r'''\g<1>
+      return null;
+\g<2>'''
 
+# Matches multi-line public static void methods:
+# Same as for public static methods, explicitly specify void return type.
+_RE_PUBLIC_STATIC_VOID_METHOD = re.compile(
+    r'^(    public static void [^{]+ {).+?^(    })$', re.DOTALL | re.MULTILINE)
+# Replacement string to replace the entire method body with an empty return.
+_RETURN = r'''\g<1>
+      return;
+\g<2>'''
 
-def _GetScriptName():
-  script_components = os.path.abspath(__file__).split(os.path.sep)
-  chrome_index = 0
-  for idx, value in enumerate(script_components):
-    if value == 'chrome':
-      chrome_index = idx
-      break
-  return os.sep.join(script_components[chrome_index:])
+_RE_CLASS = re.compile(r'\bclass (\w+)\b')
+_PRIVATE_CONSTRUCTOR = 'private {0}() {{}}\n'
 
 
-def _GetDefaultReturnVal(type_name):
-  if type_name in ('byte', 'short', 'int', 'long', 'float', 'double'):
-    return '0'
-  elif type_name == 'boolean':
-    return 'false'
-  elif type_name == 'void':
-    return ''
-  else:
-    return 'null'
+def _ParseArgs(args):
+  parser = argparse.ArgumentParser()
+  parser.add_argument('--input', required=True, help='Input java file path.')
+  parser.add_argument('--output', required=True, help='Output java file path.')
+  options = parser.parse_args(args)
+  return options
 
 
-def _ParseImports(imports):
-  """Returns dict mapping from type name to import path."""
-  import_dict = {}
-  for import_ in imports:
-    if import_.static:
-      continue
-    assert not import_.wildcard
-    name = import_.path.split('.')[-1]
-    import_dict[name] = import_.path
-  return import_dict
-
+def _EnsureSimpleFactory(content):
+  """Assert that the java factory file is very simple.
 
-def _ParsePublicMethodsSignatureTypes(clazz):
-  """Returns set of type names used in the signatures of all public methods of
-  the given class.
+  This is important since we are using the build system to swap out .class
+  files of corresponding generated and internal java factory files. Keeping the
+  factory files as simple as possible minimizes the overhead of reasoning about
+  the factory code. It is already sufficiently complex to deduce which file a
+  target is actually using when calling one of these factories.
   """
-  types = set()
-  for method in clazz.methods:
-    if 'public' in method.modifiers:
-      types.update([p.type.name for p in method.parameters])
-      # If return type is void return_type will be none.
-      if method.return_type:
-        types.add(method.return_type.name)
-  return types
-
-
-def _FormatMethod(method):
-  params = []
-  for param in method.parameters:
-    param_dict = {
-        'TYPE': param.type.name,
-        'NAME': param.name,
-    }
-    params.append(_PARAM_TEMPLATE.format(**param_dict))
-  return_type = method.return_type.name if method.return_type else 'void'
-  method_dict = {
-      'MODIFIERS': ' '.join(method.modifiers),
-      'RETURN_TYPE': return_type,
-      'NAME': method.name,
-      'PARAMS': ', '.join(params),
-      'RETURN_VAL': _GetDefaultReturnVal(return_type),
-  }
-  return (_METHOD_TEMPLATE.format(**method_dict))
-
-
-def _FormatPublicMethods(clazz):
-  methods = []
-  for method in clazz.methods:
-    if 'public' in method.modifiers:
-      methods.append(_FormatMethod(method))
-  return methods
+  classes = _RE_CLASS.findall(content)
+  assert len(classes) == 1, 'Factory must contain exactly one class.'
+  class_name = classes[0]
+  assert _PRIVATE_CONSTRUCTOR.format(class_name) in content, (
+      'Factory must have a private constructor with no arguments.')
 
 
-def _FilterAndFormatImports(import_dict, signature_types):
-  """Returns formatted imports required by the passed signature types."""
-  formatted_imports = [
-      'import %s;' % import_dict[t] for t in signature_types if t in import_dict
-  ]
-  return sorted(formatted_imports)
+def _ReplaceMethodBodies(content):
+  content = _RE_PUBLIC_STATIC_NOT_VOID_METHOD.sub(_RETURN_NULL, content)
+  content = _RE_PUBLIC_STATIC_VOID_METHOD.sub(_RETURN, content)
+  return content
 
 
 def main(args):
-  parser = argparse.ArgumentParser()
-  parser.add_argument('--input', required=True, help='Input java file path.')
-  parser.add_argument('--output', required=True, help='Output java file path.')
-  options = parser.parse_args(args)
-
+  options = _ParseArgs(args)
   with open(options.input, 'r') as f:
     content = f.read()
-
-  java_ast = javalang.parse.parse(content)
-  assert len(java_ast.types) == 1, 'Can only process Java files with one class'
-  clazz = java_ast.types[0]
-  import_dict = _ParseImports(java_ast.imports)
-  signature_types = _ParsePublicMethodsSignatureTypes(clazz)
-  formatted_public_methods = _FormatPublicMethods(clazz)
-  formatted_imports = _FilterAndFormatImports(import_dict, signature_types)
-
-  file_dict = {
-      'YEAR': str(datetime.date.today().year),
-      'SCRIPT_NAME': _GetScriptName(),
-      'PACKAGE': java_ast.package.name,
-      'IMPORTS': '\n'.join(formatted_imports),
-      'MODIFIERS': ' '.join(clazz.modifiers),
-      'CLASS_NAME': clazz.name,
-      'METHODS': '\n'.join(['    ' + m for m in formatted_public_methods])
-  }
+  _EnsureSimpleFactory(content)
+  replaced_content = _ReplaceMethodBodies(content)
   with build_utils.AtomicOutput(options.output) as f:
-    f.write(_FILE_TEMPLATE.format(**file_dict))
+    f.write(replaced_content)
 
 
 if __name__ == '__main__':
diff -drupN a/chrome/android/features/create_stripped_java_factory.pydeps b/chrome/android/features/create_stripped_java_factory.pydeps
--- a/chrome/android/features/create_stripped_java_factory.pydeps	2019-09-16 12:24:26.743149839 -0400
+++ b/chrome/android/features/create_stripped_java_factory.pydeps	2019-09-16 12:25:05.113764024 -0400
@@ -4,12 +4,4 @@
 ../../../build/android/gyp/util/build_utils.py
 ../../../build/android/gyp/util/md5_check.py
 ../../../build/gn_helpers.py
-../../../third_party/javalang/src/javalang/__init__.py
-../../../third_party/javalang/src/javalang/ast.py
-../../../third_party/javalang/src/javalang/javadoc.py
-../../../third_party/javalang/src/javalang/parse.py
-../../../third_party/javalang/src/javalang/parser.py
-../../../third_party/javalang/src/javalang/tokenizer.py
-../../../third_party/javalang/src/javalang/tree.py
-../../../third_party/javalang/src/javalang/util.py
 create_stripped_java_factory.py
