#!/usr/bin/env bash

# Unofficial Strict Mode
set -euo pipefail
IFS=$'\n\t'

# Dynamic Vars for Options with inputs
ARCH_TYPES=('arm' 'arm64' 'x86')
ARCH=${ARCH_TYPES[0]}

DARK_NAVBAR=
PATCHES_DIR=

TARGET_TYPES=('chrome_modern_public_apk' 'chrome_public_apk'
    'monochrome_public_apk')
TARGET=${TARGET_TYPES[0]}

REVISION=
REVISION_HASH=
UPSTREAM=

# Options | TODO: Add support for passing GN args in cli
opts=(
    "-a, --arch=<arch> | Where <arch> is: $(echo ${ARCH_TYPES[@]} \
        | sed -E "s/\s/, /g"). Defaults to $ARCH"
    "-d, --dark-navbar | Prefer a dark navigation bar over a white one"
    "-p, --patches-dir=<dir> | Where <dir> is a path to a directory containing custom patches" \
    "-t, --target=<target> | Where Ninja <target> is: $(echo ${TARGET_TYPES[@]} \
        | sed -E "s/\s/, /g"). Defaults to $TARGET"
    "-r, --revision=<revision> | Where <revision> is a Bromite release tag. $( \
        echo "Defaults to Bromite's latest release.")"
    "-u, --upstream | Use Bromite's git source instead of a release tag. $( \
        echo "If set, any valid Chromium release tag can be used for --revision")"
    "-h, --help | Print help menu")

# Constants
DEFAULTS=('set-revision' 'fetch-sync' 'prepare' 'build')
CWD=$(cd "$( dirname "$0" )" && pwd)
BUILD_DIR=$CWD/build
BASE_URL="https://github.com/bromite/bromite"

clean () {
    rm -rf $BUILD_DIR
}

set-revision () {
    local url

    [[ $UPSTREAM ]] \
        && REVISION_HASH=$(git ls-remote "$BASE_URL.git" HEAD \
            | awk '{print $1}' \
            | sed -E "s/^(.{7}).+/\1/") \
        && echo "Using Bromite git commit $REVISION_HASH"

    [[ $UPSTREAM ]] && [[ $REVISION ]] \
        && url="https://github.com/chromium/chromium/archive/$REVISION.tar.gz"

    [[ ! ${url:-} ]] \
        && url=$([[ $REVISION ]] \
            && echo "$BASE_URL/archive/$REVISION.tar.gz" \
            || echo "$BASE_URL/releases/latest")

    local error_msg

    [[ $REVISION ]] \
        && error_msg="Error: Release v$REVISION not found" \
        || error_msg='Error: Latest Bromite release not found. Check your network connection and try again'

    [[ $(curl -Lso /dev/null -I -w "%{http_code}" $url) != 200 ]] \
        && echo $error_msg \
        && exit 1

    if [[ ! $REVISION ]]; then
        local latest=$(curl -Lso /dev/null -w '%{url_effective}' $url)
        REVISION=${latest##*/}
    fi

    echo "Revision now set to v$REVISION"
}

fetch-sync () {
    mkdir -p $BUILD_DIR
    cd $BUILD_DIR

    local url=$([[ $REVISION_HASH ]] \
        && echo "https://api.github.com/repos/bromite/bromite/tarball/master" \
        || echo "$BASE_URL/archive/$REVISION.tar.gz")

    local tarname=$([[ $REVISION_HASH ]] \
        && echo "bromite-$REVISION_HASH" \
        || echo "bromite-$REVISION")

    # Fetch & Extract Bromite
    echo "Fetching Bromite Archive"
    curl -Lso "$tarname.tar.gz" $url

    echo "Extracting Bromite Archive"
    tar -xf "$tarname.tar.gz"

    [[ $REVISION_HASH ]] \
        && rm -rf $tarname \
        && mv bromite-$tarname $tarname

    mkdir -p chromium
    cd chromium

    # Fetch & Sync Chromium
    echo "Fetching and Syncing Chromium"

    [[ ! -e .gclient ]] \
        && fetch --nohooks android

    # Use custom debloated gclient config
    cp -f $CWD/.gclient .

    cd src

    # Reset tree
    local exclude="out/Default_${REVISION}_${ARCH}"
    git clean -fdxq --exclude=$exclude

    # Accept any y/n prompts
    echo 'y' | gclient sync --with_branch_heads --force --reset -r $REVISION
}

prepare () {
    [[ ! -d $BUILD_DIR/chromium/src ]] \
        && fetch-sync

    # Build deps if "apt-get" command detected
    [[ $(command -v apt-get) ]] \
        && ./build/install-build-deps-android.sh

    local bromite_dir=$([[ $REVISION_HASH ]] \
        && echo "$BUILD_DIR/bromite-$REVISION_HASH" \
        || echo "$BUILD_DIR/bromite-$REVISION")

    local bromite_src=$([[ -d "$bromite_dir/build" ]] \
        && echo "$bromite_dir/build" \
        || echo "$bromite_dir")

    # Prep Patching
    rm -rf $BUILD_DIR/patches

    cp -rf $bromite_src/patches \
        $BUILD_DIR/patches

    [[ $DARK_NAVBAR ]] \
        && cp -f $CWD/patches/Dark-Navbar.patch $BUILD_DIR/patches

    [[ $PATCHES_DIR ]] && [[ -d $PATCHES_DIR ]] \
        && cp -rf $PATCHES_DIR/. $BUILD_DIR/patches

    cd $BUILD_DIR/chromium/src

    # Patch List Order
    local patchlist

    [[ -e $bromite_src/patches_list.txt ]] \
        && patchlist=($(cat $bromite_src/patches_list.txt \
            | sed -e "s|^|$BUILD_DIR/patches/|g")) \
        || patchlist=($BUILD_DIR/patches/*.patch)

    # Add custom patches to patchlist
    if [[ -e $bromite_src/patches_list.txt ]]; then
        [[ $DARK_NAVBAR ]] \
            && patchlist+=($BUILD_DIR/patches/Dark-Navbar.patch)

        if [[ $PATCHES_DIR ]] && [[ -d $PATCHES_DIR ]]; then
            for patchfile in $PATCHES_DIR/*.patch; do
                [[ ! -e "$bromite_src/patches/$(basename $patchfile)" ]] \
                    && patchlist+=($patchfile)
            done
        fi
    fi

    # Apply Patches
    for patchfile in ${patchlist[@]}; do
        echo "Applying patch: $(basename $patchfile)"
        git apply --whitespace=nowarn $patchfile
    done

    # Copy Adblock Entries Header
    cp -f $bromite_src/filters/adblock_entries.h \
        net/url_request
}

build () {
    [[ ! -d $BUILD_DIR/chromium/src ]] \
        && fetch-sync \
        && prepare

    local bromite_dir=$([[ $REVISION_HASH ]] \
        && echo "$BUILD_DIR/bromite-$REVISION_HASH" \
        || echo "$BUILD_DIR/bromite-$REVISION")

    local bromite_src=$([[ -d "$bromite_dir/build" ]] \
        && echo "$bromite_dir/build" \
        || echo "$bromite_dir")

    cd $BUILD_DIR/chromium/src
    export CHROMIUM_OUTPUT_DIR="out/Default_${REVISION}_${ARCH}"
    mkdir -p $CHROMIUM_OUTPUT_DIR

    # GN_ARGS | Faster builds with no symbols and jumbo
    local gn_args_custom=(
        "target_cpu=\"$ARCH\""
        'use_jumbo_build=true')

    # Get Bromite GN Args if they exist
    local gn_args_bromite

    [[ -e $bromite_src/GN_ARGS ]] \
        && gn_args_bromite=$(cat $bromite_src/GN_ARGS \
            | tr "\n" " " \
            | sed -e "s/enable_av1_decoder\=true\s*//g" \
            | sed -e "s/symbol_level\=1/symbol_level\=0/g") \
        || gn_args_bromite=''

    # Combine GN args
    local gn_args="${gn_args_bromite}$(printf ' %s' ${gn_args_custom[@]})"

    gn gen "--args=$gn_args" $CHROMIUM_OUTPUT_DIR
    autoninja -C $CHROMIUM_OUTPUT_DIR $TARGET

    local dist_dir="$CWD/dist/$REVISION"
    local apk_basename=$(echo $TARGET \
        | sed -e 's|_apk||g' \
        | sed -e 's/^./\U&/' \
        | sed -e 's/_./\U&/g' \
        | sed -e 's/_//g')

    mkdir -p $dist_dir
    cp -f $CHROMIUM_OUTPUT_DIR/apks/$apk_basename.apk \
        $dist_dir/$apk_basename-$REVISION-$arch.apk
}

_getcmds () {
    echo $(typeset -f \
        | awk '/ \(\) $/ && !/^(main) / {print $1}' \
        | sed -E "s/(_.+\s*)//g")
}

_setopts () {
    local args_arr=($(echo $@ \
        | sed -E "s/=/ /g" \
        | tr ' ' '\n'))

    for opt in ${opts[@]}; do
        [[ $opt =~ '-h' ]] \
            && continue

        local opt_arr=($(echo $opt \
            | sed -E "s/\s*\|.+//g" \
            | sed -E "s/[=|\s]*<.+>//g" \
            | tr ", " "\n"))

        [[ ${#opt_arr[@]} != 2 ]] \
            && continue

        local opt_var=$(echo ${opt_arr[1]} \
            | sed -E "s/^--//g" \
            | sed -E "s/\W/_/g" \
            | tr '[a-z]' '[A-Z]')

        local opt_var_types=${opt_var}_TYPES[@]

        local idx=0

        for arg in ${args_arr[@]}; do
            case $arg in
                ${opt_arr[0]}|${opt_arr[1]})
                    if [[ ! $opt =~ [=|\s]*\<.+\> ]]; then
                        export "$opt_var=1"
                    elif [[ ! ${!opt_var_types:-} ]] \
                            || [[ $(printf "%s\n" ${!opt_var_types} \
                                | grep -n "^${args_arr[$idx + 1]}$") ]]; then
                        export "$opt_var=${args_arr[$idx + 1]}"
                    fi
                    ;;
            esac

            idx=$(( $idx + 1 ))
        done
    done

    # No patches directory set, return
    [[ ! $PATCHES_DIR ]] \
        && return

    local patches_dir_msg="Patches directory \"$PATCHES_DIR\" not found. Skipping"

    # Patches directory absolute path and exists, return
    if [[ $PATCHES_DIR = /* ]]; then
        [[ ! -d $PATCHES_DIR ]] \
            && echo $patches_dir_msg \
            && export PATCHES_DIR=
        return
    fi

    # Patches directory relative, update to absolute
    local patches_dir_abspath=$(cd "$( dirname "$PATCHES_DIR" )" && pwd)
    local patches_dirname=$(basename $PATCHES_DIR)

    [[ ! -d "$patches_dir_abspath/$patches_dirname" ]] \
            && echo $patches_dir_msg \
            && export PATCHES_DIR= \
            && return

    export PATCHES_DIR="$patches_dir_abspath/$patches_dirname"
}

_localbin () {
    mkdir -p $CWD/.bin

    # Depot Tools
    [[ ! -d $CWD/.bin/depot_tools ]] \
        && cd $CWD/.bin \
        && git clone -q https://chromium.googlesource.com/chromium/tools/depot_tools.git

    cd $CWD/.bin/depot_tools
    git pull -q

    export PATH=$CWD/.bin/depot_tools:$PATH

    # Use Python 2
    local python_v=$(python --version \
        | sed "s|[a-z]\s*||ig" \
        | cut -d '.' -f 1)

    [[ $python_v != 2 ]] && [[ $(command -v python2) ]] \
        && ln -sf $(which python2) $CWD/.bin/python \
        && export PATH=$CWD/.bin:$PATH
}

_help () {
cat <<HEREDOC
Usage: ${0} [command...] [options...]

Where optional [command] is one of:
    $(_getcmds | sed -E "s/\s/, /g")

If no [command] is set, the default command sequence will be executed:
$(printf "    - %s\n" ${DEFAULTS[@]})

Options:
$(printf "    %s\n" ${opts[@]} | column -t -s "|")

HEREDOC
}

main () {
    # Help Menu
    [[ $@ =~ -h|--help ]] \
        && _help \
        && return

    # Set Options
    _setopts $@

    # Setup Local bin
    _localbin

    # Detect if 1st param of args is a valid function
    if [[ ${1:-} ]] && [[ $(_getcmds) =~ $1 ]]; then
        [[ $1 != 'set-revision' ]] && [[ $1 != 'clean' ]] \
            && set-revision
        $1
        return
    fi

    # No command detected, run default sequence
    for cmd in ${DEFAULTS[@]}; do
        eval $cmd
    done
}

# Entry Function
main $@
