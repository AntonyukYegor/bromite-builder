#!/usr/bin/env bash

# Unofficial Strict Mode
set -euo pipefail
IFS=$'\n\t'

# Dynamic Vars for Options with inputs
ARCH_TYPES=('arm' 'arm64' 'x86')
ARCH=${ARCH_TYPES[0]}

NO_JAVALITE=
DARK_NAVBAR=
GN_ARGS=
PATCHES_DIR=

TARGET_TYPES=('chrome_modern_public_apk' 'chrome_public_apk'
    'monochrome_public_apk')
TARGET=${TARGET_TYPES[0]}

REVISION=
REVISION_HASH=
UPSTREAM=

# Options
opts=(
    "-a, --arch=<arch> | Where <arch> is: $(echo "${ARCH_TYPES[@]}" \
        | sed -E "s/\s/, /g"). Defaults to $ARCH"
    "-g, --gn-args=<args> | Where <args> is a string of GN build arguments"
    "-p, --patches-dir=<dir> | Where <dir> is a path to a directory containing custom patches" \
    "-t, --target=<target> | Where Ninja <target> is: $(echo "${TARGET_TYPES[@]}" \
        | sed -E "s/\s/, /g"). Defaults to $TARGET"
    "-r, --revision=<revision> | Where <revision> is a Bromite release tag. Defaults to Bromite's latest release."
    "--upstream | Use Bromite's git source instead of a release tag. If set, any Chromium tag can be assigned to <revision>"
    "--dark-navbar | Prefer a dark navigation bar over a white one"
    "--no-javalite | Use Protobuf's full Java code generator instead of Java Lite"
    "-h, --help | Print help menu")

# Constants
DEFAULTS=('set-revision' 'fetch-sync' 'prepare' 'build')
CWD=$(cd "$( dirname "$0" )" && pwd)
BUILD_DIR=$CWD/build
BASE_URL="https://github.com/bromite/bromite"

clean () {
    rm -rf "$BUILD_DIR"
}

set-revision () {
    local url
    local error_msg
    local latest

    [[ $UPSTREAM ]] \
        && REVISION_HASH=$(git ls-remote "$BASE_URL.git" HEAD \
            | awk '{print $1}' \
            | sed -E "s/^(.{7}).+/\1/") \
        && echo "Using Bromite git commit $REVISION_HASH"

    [[ $UPSTREAM ]] && [[ $REVISION ]] \
        && url="https://github.com/chromium/chromium/archive/$REVISION.tar.gz"

    [[ ! ${url:-} ]] \
        && url=$([[ $REVISION ]] \
            && echo "$BASE_URL/archive/$REVISION.tar.gz" \
            || echo "$BASE_URL/releases/latest")

    [[ $REVISION ]] \
        && error_msg="Error: Release v$REVISION not found" \
        || error_msg='Error: Latest Bromite release not found. Check your network connection and try again'

    [[ $(curl -Lso /dev/null -I -w "%{http_code}" "$url") != 200 ]] \
        && echo "$error_msg" \
        && exit 1

    if [[ ! $REVISION ]]; then
        latest=$(curl -Lso /dev/null -w '%{url_effective}' "$url")
        REVISION=${latest##*/}
    fi

    echo "Revision now set to $REVISION"
}

fetch-sync () {
    local url
    local tarname

    mkdir -p "$BUILD_DIR"
    cd "$BUILD_DIR"

    url=$([[ $REVISION_HASH ]] \
        && echo "https://api.github.com/repos/bromite/bromite/tarball/master" \
        || echo "$BASE_URL/archive/$REVISION.tar.gz")

    tarname=$([[ $REVISION_HASH ]] \
        && echo "bromite-$REVISION_HASH" \
        || echo "bromite-$REVISION")

    # Fetch & Extract Bromite
    echo "Fetching Bromite Archive"
    curl -Lso "$tarname.tar.gz" "$url"

    echo "Extracting Bromite Archive"
    tar -xf "$tarname.tar.gz"

    [[ $REVISION_HASH ]] \
        && rm -rf "$tarname" \
        && mv "bromite-$tarname" "$tarname"

    mkdir -p chromium
    cd chromium

    # Fetch & Sync Chromium
    echo "Fetching and Syncing Chromium"

    # Fetch does not support partial checks, delete and start over (crbug.com/230691)
    [[ ! -e .gclient ]] || [[ ! -e .gclient_entries ]] || [[ ! -d .cipd ]] \
        && rm -rf ../chromium/{*,.g*,.c*} \
        && fetch --nohooks android

    # Use custom debloated gclient config
    cp -f "$CWD/.gclientconfig" .gclient

    cd src

    # Reset tree
    local exclude="out/Default_${REVISION}_${ARCH}"
    git clean -fdxq --exclude="$exclude"

    # Accept any y/n prompts
    echo 'y' | gclient sync --with_branch_heads --force --reset -D -r "$REVISION"
}

prepare () {
    local bromite_dir
    local bromite_src
    local patchlist

    [[ ! -d $BUILD_DIR/chromium/src ]] \
        && fetch-sync

    # Build deps if "apt-get" command detected
    [[ $(command -v apt-get) ]] \
        && ./build/install-build-deps-android.sh

    bromite_dir=$([[ $REVISION_HASH ]] \
        && echo "$BUILD_DIR/bromite-$REVISION_HASH" \
        || echo "$BUILD_DIR/bromite-$REVISION")

    bromite_src=$([[ -d "$bromite_dir/build" ]] \
        && echo "$bromite_dir/build" \
        || echo "$bromite_dir")

    # Prep Patching
    rm -rf "$BUILD_DIR/patches"

    cp -rf "$bromite_src/patches" \
        "$BUILD_DIR/patches"

    [[ $DARK_NAVBAR ]] \
        && cp -f "$CWD/patches/Dark-Navbar.patch" \
            "$BUILD_DIR/patches"

    [[ $NO_JAVALITE ]] \
        && cp -f "$CWD/patches/No-Javalite.patch" \
            "$BUILD_DIR/patches"

    [[ $PATCHES_DIR ]] && [[ -d $PATCHES_DIR ]] \
        && cp -rf "$PATCHES_DIR/." \
            "$BUILD_DIR/patches"

    cd "$BUILD_DIR/chromium/src"

    # Patch List Order
    [[ -e $bromite_src/patches_list.txt ]] \
        && patchlist=($(cat "$bromite_src/patches_list.txt" \
            | sed -e "s|^|$BUILD_DIR/patches/|g")) \
        || patchlist=($BUILD_DIR/patches/*.patch)

    # Add custom patches to patchlist
    if [[ -e $bromite_src/patches_list.txt ]]; then
        [[ $DARK_NAVBAR ]] \
            && patchlist+=("$BUILD_DIR/patches/Dark-Navbar.patch")

        [[ $NO_JAVALITE ]] \
            && patchlist+=("$BUILD_DIR/patches/No-Javalite.patch")

        if [[ $PATCHES_DIR ]] && [[ -d $PATCHES_DIR ]]; then
            for patchfile in $PATCHES_DIR/*.patch; do
                [[ ! -e "$bromite_src/patches/$(basename "$patchfile")" ]] \
                    && patchlist+=("$patchfile")
            done
        fi
    fi

    # Apply Patches
    for patchfile in "${patchlist[@]}"; do
        [[ "$(git apply --check "$patchfile" &>/dev/null; echo $?)" -gt 0 ]] \
            && echo "Skipping, doesn't apply: $(basename "$patchfile")" \
            && continue
        echo "Applying patch: $(basename "$patchfile")"
        git apply --whitespace=nowarn "$patchfile"
    done

    # Copy Adblock Entries Header
    cp -f "$bromite_src/filters/adblock_entries.h" \
        net/url_request
}

build () {
    local bromite_dir
    local bromite_src

    local gn_args_bromite
    local gn_args_user_arr
    local gn_args

    local dist_dir
    local dist_apk_basename
    local apk_basename

    [[ ! -d $BUILD_DIR/chromium/src ]] \
        && fetch-sync \
        && prepare

    # V8 Compiler Optimization Workaround | https://crbug.com/942497
    sed -i 's|"-O0"|"-O2"|g' \
        "$BUILD_DIR/chromium/src/build/config/compiler/BUILD.gn"

    bromite_dir=$([[ $REVISION_HASH ]] \
        && echo "$BUILD_DIR/bromite-$REVISION_HASH" \
        || echo "$BUILD_DIR/bromite-$REVISION")

    bromite_src=$([[ -d "$bromite_dir/build" ]] \
        && echo "$bromite_dir/build" \
        || echo "$bromite_dir")

    cd "$BUILD_DIR/chromium/src"
    export CHROMIUM_OUTPUT_DIR="out/Default_${REVISION}_${ARCH}"
    mkdir -p "$CHROMIUM_OUTPUT_DIR"

    # Get Bromite GN Args if they exist
    [[ -e $bromite_src/GN_ARGS ]] \
        && gn_args_bromite=$(cat "$bromite_src/GN_ARGS" \
            | tr "\n" " " \
            | sed -e "s/symbol_level\=1/symbol_level\=0/g") \
        || gn_args_bromite=''

    # Combine default GN args
    gn_args="target_cpu=\"$ARCH\" ${gn_args_bromite}$(printf \
        ' %s' "${gn_args_custom_arr[@]}")"

    # Cast user GN args to array
    gn_args_user_arr=($(echo $GN_ARGS | tr " " "\n"))

    # Update GN args with user-defined args taking priority
    for arg in "${gn_args_user_arr[@]}"; do
        local arg_key
        arg_key=$(echo "$arg" | sed -E 's/=.+//')

        [[ $arg_key == 'target_cpu' ]] \
            && continue

        [[ $(echo "$gn_args" | grep "$arg_key=") ]] \
            && gn_args=$(echo "$gn_args" \
                | sed -E "s/\\s$arg_key=\\S+/ $arg/g") \
            || gn_args="${gn_args} ${arg}"
    done

    # Normalize Whitespace
    gn_args=$(echo "$gn_args" | sed -E 's/\s+/ /g')

    # Build
    gn gen "--args=$gn_args" "$CHROMIUM_OUTPUT_DIR"
    autoninja -C "$CHROMIUM_OUTPUT_DIR" "$TARGET"

    # Prep ./dist dir
    dist_dir="$CWD/dist"
    mkdir -p "$dist_dir"

    # Copy and Rename APK to ./dist
    apk_basename=$(echo "$TARGET" \
        | sed -e 's|_apk||g' \
        | sed -e 's/^./\U&/' \
        | sed -e 's/_./\U&/g' \
        | sed -e 's/_//g')

    [[ $DARK_NAVBAR ]] \
        && dist_apk_basename="$apk_basename-DarkNavbar" \
        || dist_apk_basename="$apk_basename"

    dist_apk_basename="$dist_apk_basename-$REVISION-$ARCH"

    cp -f "$CHROMIUM_OUTPUT_DIR/apks/$apk_basename.apk" \
        "$dist_dir/$dist_apk_basename.apk"
}

_setopts () {
    # Cast args to array for easier parsing
    local args_arr=()

    for arg in $*; do
        [[ ! $arg =~ (--[a-z|-]+)= ]] \
            && args_arr+=("$arg") \
            && continue

        local arg_key
        local arg_value

        arg_key=$(echo "$arg" | sed -E 's/=.+//')
        arg_value=$(echo "$arg" | sed -E "s/$arg_key=//")

        args_arr+=("$arg_key")
        args_arr+=("$arg_value")
    done;

    # Iterate options and assign var values to CLI args
    for opt in "${opts[@]}"; do
        [[ $opt =~ '-h' ]] \
            && continue

        local opt_arr=($(echo "$opt" \
            | sed -E "s/\s*\|.+//g" \
            | sed -E "s/=<.+>//g" \
            | tr ", " "\n"))

        [[ ${#opt_arr[@]} != 2 ]] \
            && opt_arr+=("${opt_arr[0]}")

        local opt_var
        local opt_var_types
        local idx=0

        opt_var=$(echo "${opt_arr[1]}" \
            | sed -E "s/^--//g" \
            | sed -E "s/\W/_/g" \
            | tr '[a-z]' '[A-Z]')

        opt_var_types=${opt_var}_TYPES[@]

        for arg in "${args_arr[@]}"; do
            case $arg in
                ${opt_arr[0]}|${opt_arr[1]})
                    if [[ ! $opt =~ \=\<.+\> ]]; then
                        export "$opt_var=1"
                    elif [[ ! ${!opt_var_types:-} ]] \
                            || [[ $(printf "%s\n" ${!opt_var_types} \
                                | grep -n "^${args_arr[$idx + 1]}$") ]]; then
                        export "$opt_var=${args_arr[$idx + 1]}"
                    fi
                    ;;
            esac

            idx=$(( "$idx" + 1 ))
        done
    done

    _localpatches
}

_localpatches () {
    local patches_dir_msg
    local patches_dir_abspath
    local patches_dirname

    # No patches directory set, return
    [[ ! $PATCHES_DIR ]] \
        && return

    patches_dir_msg="Patches directory \"$PATCHES_DIR\" not found. Skipping"

    # Patches directory absolute path and exists, return
    if [[ $PATCHES_DIR = /* ]]; then
        [[ ! -d $PATCHES_DIR ]] \
            && echo "$patches_dir_msg" \
            && export PATCHES_DIR=
        return
    fi

    # Patches directory relative, update to absolute
    patches_dir_abspath=$(cd "$( dirname "$PATCHES_DIR" )" && pwd)
    patches_dirname=$(basename $PATCHES_DIR)

    [[ ! -d "$patches_dir_abspath/$patches_dirname" ]] \
            && echo "$patches_dir_msg" \
            && export PATCHES_DIR= \
            && return

    export PATCHES_DIR="$patches_dir_abspath/$patches_dirname"
}

_localbin () {
    local python_v

    mkdir -p "$CWD/.bin"

    # Depot Tools
    [[ ! -d $CWD/.bin/depot_tools ]] \
        && cd "$CWD/.bin" \
        && echo "Fetching Depot Tools" \
        && git clone -q https://chromium.googlesource.com/chromium/tools/depot_tools.git

    cd "$CWD/.bin/depot_tools"
    git pull -q

    export PATH=$CWD/.bin/depot_tools:$PATH

    # Use Python 2
    python_v=$(python --version \
        | sed "s|[a-z]\s*||ig" \
        | cut -d '.' -f 1)

    [[ $python_v != 2 ]] && [[ $(command -v python2) ]] \
        && ln -sf "$(command -v python2)" "$CWD/.bin/python" \
        && export PATH=$CWD/.bin:$PATH
}

_getcmds () {
    echo $(typeset -f \
        | awk '/ \(\) $/ && !/^(main) / {print $1}' \
        | sed -E "s/(_.+\s*)//g")
}

_help () {
cat <<HEREDOC
Usage: ${0} [command...] [options...]

Where optional [command] is one of:
    $(_getcmds | sed -E "s/\s/, /g")

If no [command] is set, the default command sequence will be executed:
$(printf "    - %s\n" "${DEFAULTS[@]}")

Options:
$(printf "    %s\n" "${opts[@]}" | column -t -s "|")

HEREDOC
}

main () {
    # Help Menu
    [[ $(echo "$@") =~ -h|--help ]] \
        && _help \
        && return

    # Set Options
    _setopts "$@"

    # Setup Local bin
    _localbin

    # Detect if 1st param of args is a valid function
    if [[ ${1:-} ]] && [[ $(_getcmds) =~ $1 ]]; then
        [[ $1 != 'set-revision' ]] && [[ $1 != 'clean' ]] \
            && set-revision
        $1
        return
    fi

    # No command detected, run default sequence
    for cmd in "${DEFAULTS[@]}"; do
        eval "$cmd"
    done
}

# Entry Function
main "$@"
